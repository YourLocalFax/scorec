
struct vec2 {
   x : r32
   y : r32
}

proc new_vec2(x : r32, y : r32) -> vec2 = {
   let result : vec2
   result.x = x
   result.y = y

   result
}

proc vec2_add(a : vec2, b : vec2) -> vec2 =
   new_vec2(a.x + b.x, a.y + b.y)

/*
proc test() {
   /# the type of `v` is `vec2`.
   /# that's a qualified type name.
   /# what if the compiler substitutes qualified
   /#  type names with the types they point to?
   /# would that be simpler?
   /# would that matter?
   /# it would skip the lookup-in-symbol-table step...
   let v : vec2
   /# v.x -> gets v, determines type, gets x.
   /# for doing this with structs, I need to know
   /#  how to determine what fields a struct has.
   /# qualified types merely point at the type and
   /#  allow type checking to occur without care
   /#  for what that type contains.
   /# when we actually care about that, what do we do?
   /# I'm thinking that the `vec2` symbol, in this case,
   /#  will store the actual type information in it.
   /# this way, when we get a struct type we can look
   /#  up its fields via the symbol table.
   let x = v.x
}
*/
